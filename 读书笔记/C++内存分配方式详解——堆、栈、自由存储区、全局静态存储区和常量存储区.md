http://www.cnblogs.com/daocaoren/archive/2011/06/29/2092957.html  
http://blog.csdn.net/qibanxuehua/article/details/52702606
## 栈
就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是**局部变量、函数参数**等。在一个进程中，位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数的调用
## 堆
就是那些由 new 分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个 new 就要对应一个 delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。堆可以动态地扩展和收缩。
## 自由存储区
就是那些由 malloc 等分配的内存块，他和堆是十分相似的，不过它是用 free 来结束自己的生命的
> 首先 new/delete 是 c/c++ 语言的运算符，malloc/free 是 c/c++ 语言的标准库函数。new 可以认为是 malloc 加构造函数的执行，new 出来的指针是直接带类型信息的，而 malloc 返回的都是 void 指针。在执行运算符 delete 时相应地会调用对象的析构函数，而调用 free 函数时则不会——这是很有用的：当你类里面包含了其他类的指针变量并且你在你类的析构函数里面释放了该指针变量，通过执行 delete 运算符能隐式调用对象的析构函数来释放指针变量所指向的空间。

## 全局/静态存储区
全局变量和静态变量被分配到同一块内存中，在以前的 C 语言中，全局变量又分为初始化的和未初始化的（初始化的全局变量和静态变量在一块区域，未初始化的全局变量与静态变量在相邻的另一块区域，同时未被初始化的对象存储区可以通过 void* 来访问和操纵，程序结束后由系统自行释放），在 C++ 里面没有这个区分了，他们共同占用同一块内存区

## 常量存储区
这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改，而且方法很多）

## e.g
```c
void f() { int* p=newint[5]; }
```
这条短短的一句话就包含了堆与栈，看到 new，我们首先就应该想到，我们分配了一块堆内存，那么指针 p 呢？他分配的是一块栈内存，所以这句话的意思就是：在栈内存中存放了一个指向一块堆内存的指针 p。在程序会先确定在堆中分配内存的大小，然后调用 operator new 分配内存，然后返回这块内存的首地址，放入栈中

## 堆和栈究竟有什么区别？
1. 管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。
2. 空间大小：一般来讲在 32 位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的
3. 碎片问题：对于堆来讲，频繁的 new/delete 势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出
4. 生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。
5. 分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 malloc 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现
6. 分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是 C/C++ 函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。

## static
1. 类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致了它仅能访问类的静态数据和静态成员函数。
2. 不能将静态成员函数定义为虚函数
3. 由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊，变量地址是指向其数据类型的指针，函数地址类型是一个“nonmember 函数指针”。
4. 静态数据成员是静态存储的，所以必须对它进行初始化
5. int n=3; //默认为extern   
static int j=5; //声明为static   
全局变量和静态变量j都存放于程序的全局数据区域，它们的生存周期都是程序的整个运行期，但是n的作用域为全局作用域，可以通过extern在其他文件中使用，而j只能在文件A中使用，例如在文件B中：  
extern int n; //ok   
extern int j; //error: j在文件B中不可见   
int a=n;//ok：但这里有个初始化先后的问题，具体参见参考一   
int b=j;//error  
也就是说，在声明全局的static变量时，static没有改变它的生存周期，也即存储位置（因为全局变量本来就存储在全局数据域），而是将变量的作用域限制在当前文件中。
6. static全局变量与普通的全局变量有什么区别 ?  
(1)存储方式上并无不同   
(2)这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。
static全局变量只初使化一次，防止在其他文件单元中被引用; 　
7. static局部变量和普通局部变量有什么区别 ？  
(1)把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。  
(2)static局部变量只被初始化一次，下一次依据上一次结果值； 　
8. static函数与普通函数有什么区别？
(1)static函数与普通函数作用域不同,仅在本文件。**只在当前源文件中使用的函数应该说明为内部函数(static修饰的函数)**，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件.  
(2)static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝
