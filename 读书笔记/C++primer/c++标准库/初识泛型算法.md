
* [泛型算法](#泛型算法)
  * [1概述](#1概述)
    * [1.1背景](#11背景)
    * [1.2算法的头文件](#12算法的头文件)
    * [1.3算法如何工作](#13算法如何工作)
  * [2初识泛型算法](#2初识泛型算法)
    * [2.1只读算法](#21只读算法)
      * [2.1.1find算法](#211find算法)
      * [2.1.2accumulate算法--```#include<numeric>```](#212accumulate算法-includenumeric)
      * [2.1.3算法和元素类型](#213算法和元素类型)
      * [2.1.4操作两个序列的算法----equal算法](#214操作两个序列的算法-equal算法)
    * [2.2写容器元素的算法---改变容器元素](#22写容器元素的算法-改变容器元素)
      * [2.2.1fill算法](#221fill算法)
      * [2.2.2算法不检查写操作](#222算法不检查写操作)
      * [2.2.3介绍back_inserter.头文件iterator中的一个函数](#223介绍back_inserter头文件iterator中的一个函数)
      * [2.2.4拷贝算法](#224拷贝算法)
      * [2.2.5replace算法](#225replace算法)
    * [2.3重排容器元素的算法](#23重排容器元素的算法)
      * [2.3.1消除重复单词](#231消除重复单词)
      * [2.3.1使用容器操作删除元素](#231使用容器操作删除元素)


## 泛型算法

特点：1.提供经典算法的公共借口2.泛型：可以用于不同类型的元素和多种容器类型和一起的序列  
### 1概述
#### 1.1背景  
顺序容器只定义了很少的操作：在多数情况下，我们可以添加和删除元素。访问首尾元素、确定容器是否为空以及获得指向首元素或尾元素之后位置的迭代器。

算法并不直接操作容器，而是遍历由两个迭代器指定的一个**元素范围**来进行操作

#### 1.2算法的头文件
大多数算法都定义在头文件**algorithm**中。标准库还在头文件**numeric**中定义了一组数值泛型算法  


#### 1.3算法如何工作
概念上，find应该执行如下步骤：

1 访问序列中的首元素

2 比较此元素与我们要查找的值

3 如果此元素与我们要查找的值匹配，find返回标识此元素的值。

4 否则，find前进到下一个元素，重复执行步骤2和3

5 如果到达序列尾，find应停止

6 如果find到达序列尾，它应该返回一个指出元素未找到的值。此值和步骤3返回的值必须具有相容的类型。

这些步骤都不依赖于容器所保存的元素类型。因此，只要有一个**迭代器**可用来访问元素，find就完全不依赖于容器类型（甚至无须理会保存元素的是不是容器）。  

**算法永远不会执行容器的操作  
算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素**  
<font color=#0099ff>泛型算法本身不会执行容器的操作，它们只会运行与迭代器之上，执行迭代器的操作。</font>   

### 2初识泛型算法     
除了少数例外，**标准库算法都对一个范围内的元素进行操作**。我们将此元素范围称为“输入范围”。接受输入范围的算法总是使用前两个参数来表示此范围，两个参数分别是指想要处理的第一个元素和尾元素之后位置的迭代器。

虽然大多数算法遍历输入范围的方式相似，但它们使用范围中元素的方式不同。**理解算法的最基本的方法就是了解它们是否读取元素、改变元素、或是重排元素顺序。**  
#### 2.1只读算法
> 只会读取其输入范围内的元素，而从不改变元素  

##### 2.1.1find算法
```c
template <class InIt, class T>  
     InIt find(InIt first, InIt last, const T& val);  
```
 查询迭代器指定范围[first, last)范围内是否有val值。如果有，则返回该值对应的迭代器；否则，返回last表示查找失败。  
```c
int val=42;
auto result=find(vec.cbegin(),vec.cend(),val);
```
**由于指针就像内置数组上的迭代器一样**  
```c
int ia[]={27,210,12,47,109,83};

int val=83;

int *result=find(begin(ia),end(ia),val);
auto result=find(ia+1,ia+4;val);//元素范围来进行操作
```
##### 2.1.2accumulate算法--```#include<numeric>```
```c
template<class InIt, class T>
   T accumulate(InIt first, InIt last, T val);
template<class InIt, class T, class Pred>
   T accumulate(InIt first, InIt last, T val, Pred pr);
```
int sum=accumulate(vec.cbegin(),vec.cend(),0);  
这条语句将sum设置为vec中元素的和，和的初值被设置为0.  
**accumulate的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型。**

##### 2.1.3算法和元素类型
```c
string sum=accumulate(v.cbegin(),v.cend(),string(""));
//错误：const char*上没有定义+运算符
string sum=accumulate(v.cbegin(),v.cend(),"");
```
##### 2.1.4操作两个序列的算法----equal算法
用于确定两个序列是否保存相同的值，它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果所有对应元素都相等，则返回true，否则返回false。此算法接受三个迭代器：前两个表示第一个序列中的元素的范围，第三个表示第二个序列的首元素：
```c
//roster2中的元素数目应该至少与roster1一样多
equal(roster1.cbegin(),roster1.cend(),roster2.cbegin());
```
由于equal利用迭代器完成操作，因此我们可以通过调用equal来比较两个不同类型的容器中的元素。而且，元素类型也不必一样，只要我们能用==来比较两个元素类型即可.**equal基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长**
#### 2.2写容器元素的算法---改变容器元素
> 记住，算法不会执行容器操作，因此它们自身不可能改变容器的大小。

##### 2.2.1fill算法
```c
template<class FwdIt, class T>
    void fill(FwdIt first, FwdIt last, const T& x);
e.g
fill(vec.begin(),vec.end(),0); //将每个元素重置为0

//将容器的一个子序列设置为10

fill(vec.begin(),vec.begin()+vec.size()/2,10);
```
这个算法将指定范围内的每个元素都设定为给定的值。如果输入范围有效，则可以安全写入。这个算法只会对输入范围内已存在的元素进行写入操作

##### 2.2.2算法不检查写操作
> 向目的迭代器写入数据的算法假定目的位置是足够大，能容纳要写入的元素。
```c
e.g
vector<int> vec;  //空向量
//灾难：修改vec中10个（不存在）元素
fill_n(vec.begin(),10,0);
```

##### 2.2.3介绍back_inserter.头文件iterator中的一个函数
一种保证算法有足够元素空间来容纳输出数据的方法是使用插入迭代器  
back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中：
```c
vector<int> vec;   //空容器
auto it=back_inserter(vec); //通过它赋值会将元素添加到vec中
*it=42;//vec现在有一个元素，值为42
```

我们常常使用back_inserter来创建一个迭代器，作为算法的**目的位置**来使用。例如：  
vector<int> vec;  //空向量  
//正确：back_inserter创建一个插入迭代器，可以用来向vec添加元素  
fill_n(back_inserter(vec),10,0);  //添加10个元素到vec

在每步迭代中，fill_n向给定容器序列的一个元素赋值。由于我们传递的参数是back_inserter返回的迭代器，因此每次赋值都会在vec上调用push_back。最终，这条fill_n调用语句向vec的末尾添加了10个元素，每个元素的值都是0.

##### 2.2.4拷贝算法
- 拷贝算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法  
- 此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。  
- 传递给copy的目的序列至少要包含与输入序列一样多的元素，这一点很重要

```c
int a[]={0,1,2,3,4,5,6,7,8,9};

int a2[sizeof(a1)/sizeof(*a1)];

auto ret=copy(begin(a1),end(a1),a2); //把a1的内容拷贝到a2
```
**copy返回的是其目的位置迭代器（递增后）的值。即，ret恰好指向拷贝到a2的尾元素之后的位置。**
##### 2.2.5replace算法
- replace算法读入一个序列，并将其中所有等于给定值的元素都改为另一个值。  
- 此算法接受4个参数：前两个是迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值。它将所有等于第一个值的元素替换为第二个值：

```c
//将所有值为0的元素改为42
replace(ilist.begin(),ilist.end(),0,42);
```
- 此调用将序列中所有0都替换为42,。如果我们希望保留原序列不变，可以调用replace_copy。此算法接受额外第三个迭代器参数，指出调整后序列的保存位置：

```c
//使用back_inserter按需要增长目标序列
replace_copy(ilist.begin(),ilist.end(),back_inserter(ivec),0,42);
```
此调用后，ilis并未改变，ivec包含与ilist的一份拷贝，不过原来在ilist中值为0的元素在ivec中都变为42
#### 2.3重排容器元素的算法  
> 某些算法会重排容器中元素的顺序，一个明显的例子是sort。调用sort会重排输入序列中的元素，使之有序，它是利用元素类型的<运算符来实现排序的。

##### 2.3.1消除重复单词
为了消除重复单词，首先将vector排序，使得重复的单词都相邻出现。一旦vector排序完毕，我们就可以使用另一个称为unique的标准库算法来重排vector，使得不重复的元素出现在vector的开始部分，由于算法不能执行容器的操作，我们将使用vector的erase成员来完成真正的删除操作：
```c
void elimDups(vector<string> &words)
{
        //按字典序排序words，以便查找重复单词
        sort(words.begin(),words.end());
        //unique重排输入范围，使得每个单词只出现一次
        //排列在范围的前部，返回指向不重复区域之后一个位置的迭代器
        auto end_unique=unique(words.begin(),words.end());
        words.erase(end_unique,words.end());
}
```
words排序完毕后，我们希望将每个单词都只保存一次。**unique算法重排输入序列，将相邻的重复项“消除”，并返回一个指向不重复范围末尾的迭代器。**

words的大小并未改变，但是这些元素的顺序被改变了——相邻的重复元素被“删除”了。我们将删除打引号是因为unique并不真正的删除任何元素，**它只是覆盖相邻的重复元素**，使得不重复元素出现在序列开始部分，unique返回的迭代器指向最后一个不重复元素之后的位置。此位置之后的元素仍然存在，但我们不知道它们的值是什么。

**标准库算法对迭代器而不是容器进行操作。因此，算法不能（直接）添加或删除元素。**

##### 2.3.1使用容器操作删除元素
为了真正删除无用元素，我们必须使用容器操作，本例中使用erase。我们删除从end_unique开始直至words末尾的范围内的所有元素。这个调用之后，words包含的重复元素真正被删除了
