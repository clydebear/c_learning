- [拷贝控制](#拷贝控制)
    - [拷贝构造函数](#拷贝构造函数)
        - [合成的拷贝构造函数](#合成的拷贝构造函数)
        - [拷贝初始化](#拷贝初始化)
        - [参数和返回值](#参数和返回值)
        - [拷贝初始化也有限制](#拷贝初始化也有限制)
        - [编译器可以绕过拷贝构造函数](#编译器可以绕过拷贝构造函数)
    - [拷贝赋值运算符](#拷贝赋值运算符)
        - [拷贝赋值运算符是一个重载的赋值运算符](#拷贝赋值运算符是一个重载的赋值运算符)
        - [合成的拷贝赋值运算符](#合成的拷贝赋值运算符)
    - [析构函数](#析构函数)
        - [析构函数作用](#析构函数作用)
        - [何时调用](#何时调用)
        - [合成的析构函数](#合成的析构函数)
        - [三/五法则](#三/五法则)
        - [=default：](#=default：)
        - [=delete：](#=delete：)
        - [析构函数不能是删除的成员](#析构函数不能是删除的成员)
    - [private 拷贝控制](#private 拷贝控制)
- [拷贝控制和资源管理](#拷贝控制和资源管理)
    - [定义行为像值的类](#定义行为像值的类)
    - [定义行为像指针的类](#定义行为像指针的类)
- [交换操作](#交换操作)
- [对象移动](#对象移动)
    - [右值引用](#右值引用)
    - [标准库move函数：](#标准库move函数：)
    - [移动构造函数和移动赋值运算符](#移动构造函数和移动赋值运算符)
    - [移动赋值运算符：](#)
    - [合成的移动操作：](#)
    - [移动迭代器](#)
    - [移动右值，拷贝左值。。。](#)
    - [但没有移动构造函数，右值也被拷贝](#)
    - [右值引用和成员函数](#右值引用和成员函数)
    - [右值和左值引用函数：](#右值和左值引用函数：)
    - [重载和引用函数：](#重载和引用函数：)
# 拷贝控制
拷贝控制操作包括：对象拷贝、移动(新标准定义的)、赋值和销毁  
对应的操作有，拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数  
## 拷贝构造函数
一个构造函数的第一个参数是自身类类型的引用，额外的参数(如果有)都有默认值，那么这个构造函数是拷贝构造函数。**拷贝构造函数的第一个参数必须是一个引用类型。**
```c
class foo{
public:
  foo();//默认构造函数
  foo(const foo&);//拷贝构造函数
}
```
拷贝构造函数一般都是被隐式地使用所以通常不是explicit的  
### 合成的拷贝构造函数  
在我们没有定义自己的拷贝构造函数，编译器会为我们合成一个。但是对于有些类来说，合成拷贝构造函数用来阻止我们拷贝该类类型的对象。而一般情况，合成拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中，编译器依次将每个非static成员拷贝到正在创建的对象中。
<font color=#0099ff>每个成员的类型决定了它如何拷贝：对类类型的成员， 会使用其拷贝构造函数来拷贝；内置类型的成员直接拷贝；对于数组而言不能直接拷贝，但是我们的拷贝构造函数会逐元素的拷贝一个数组类型的成员。</font>

```c
//这个拷贝构造函数与合成的等价
class Sales_data {  
public:  
    Sales_data(const Sales_data&);  

private:  
    std::string bookNo;  
    int units_sold = 0;  
    double revenue = 0.0;  

};  

Sales_data::Sales_data(const Sales_data& data) : bookNo(data.bookNo),  
                         units_sold(data.units_sold),  
                         revenue(data.revenue)  
{  
}  
```

### 拷贝初始化
```c
string dots(10, '.'); // 直接初始化  
string s(dots); // 直接初始化  
string s2 = dots; // 拷贝初始化  
string null_book = "9-999-99999-9"; // 拷贝初始化  
string nines = string(100, '9');  // 拷贝初始化
```

**直接初始化和拷贝初始化的区别**：对于直接初始化，实际上时要求编译器调用普通的函数匹配来选择我们所提供的参数**最匹配**的构造函数。 对于拷贝初始化，要求编译器将右侧正在运算的对象拷贝到正常创建的对象中，需要的话进行类型转换。  
拷贝初始化，除了发生在用 = 定义变量时发生，以下情况也会发生：  
- 将一个对象作为参数传递给一个非引用类型的形参
- 将一个对象作为返回值从一个返回值为非引用类型的函数返回时
- 用花括号列表初始化一个数组中的元素或者一个聚合类中的成员  

除此之外，我们在调用标准库容器的insert成员或push成员时，容器会对其参数进行**拷贝初始化**；在调用emplace成员时，会调用与这个容器的构造函数参数最匹配的构造函数来进行直接初始化。  
### 参数和返回值
/\* 非常重要 ！！！\* /  
☆ 拷贝构造函数被用来初始化非引用类类型参数。 如果其参数不是引用类型，则调用永远不会成功，为了调用拷贝构造用函数，我们必须拷贝它的实参，但为 了拷贝实参，我们必须调用拷贝构造函数，如此无限循环。   
就是说要不断的拷贝，引用就可以避免这种情况发生

### 拷贝初始化也有限制
如果对一个类的初始化要求通过一个explicit的构造函数来进行类型转换，那么使用拷贝初始化和直接初始化就不是无关紧要的了：  
```c
vector<int> v1(10); // 正确，直接初始化  
vector<int> v2 = 10; // 错误，接收大小参数的构造函数时explicit的  
void f(vector<int>); // f的参数进行拷贝初始化  
f(10); // 错误，不能用一个explicit的构造函数拷贝一个实参  
f(vector<int>(10)）; // 正确，从一个int直接构造一个临时vector  
```

接受一个大小参数的构造函数是explicit的，意味着我们只能进行直接初始化而不能进行拷贝初始化；因此，我们不能用一个explicit的构造函数来拷贝一个参数，这里的拷贝有参数传递和函数的非引用返回值，如果我们希望使用一个explicit的构造函数时，必须显示的使用，比如上述代码的最后一行那样。

### 编译器可以绕过拷贝构造函数  
拷贝初始化的过程中，编译器可以 ( 但不是必须! ) 跳过拷贝/移动构造函数，直接创建对象
```c
string null_book = "123456";  
```
可以改写为：
```c
string null_book("123456");  
```
即使有时候编译器可以跳过拷贝/移动构造函数，但是我们必须保证拷贝/移动构造函数是存在而且是可访问的(例如：不能是private)。
## 拷贝赋值运算符
```c
Sales_data trans, accum;  
trans = accum; // 使用Sales_data的拷贝赋值运算符  
```
### 拷贝赋值运算符是一个重载的赋值运算符
重载运算符本质上时函数，由operator关键字后跟要定义的运算符的符号组成。重载运算符的参数表示运算符的运算对象。  
拷贝赋值运算符必须定义为成员函数，其左则对象被绑定到隐式的this指针上。  
拷贝赋值运算符接受一个与其所在类相同类型的参数：  
```c
class Foo {  

public:  
    Foo& operator =(const Foo&); // 拷贝赋值运算符  

    // ...  
};  
```
为了和内置类型的赋值保持一致，类的拷贝赋值运算符通常返回一个指向其左则对象的引用。应当注意的是，标准库要求保存的类型要具有赋值运算符，且**返回值是左则运算对象的引用。**   

### 合成的拷贝赋值运算符
如果我们未对一个类定义自己的拷贝赋值运算符，那么编译器负责为我们生成一个合成的拷贝赋值运算符。**它会将右侧的运算对象的每个非static成员赋予左侧对象的对应成员**，这一操作时通过成员的赋值运算符来完成的。对于数组类型，逐个赋值数组元素。   
```c
Sales_data& Sales_data::operator = (const Sales_data& data) {  
    bookNo      =   data.bookNo; // 调用std::string::operator =  
    units_sold  =   data.units_sold; // 使用内置的int赋值  
    revenue     =   data.revenue; // 使用内置的double赋值  
    return * this; // 返回左则运算对象的引用  
}  
```
<font color=#0099ff>合成的拷贝赋值运算符返回一个指向其左侧对象的引用。</font>
## 析构函数
析构函数执行和构造函数相反的操作，构造函数用于初始化非statci成员，还可能做其他的一些工作，析构函数用于释放对象使用的资源，并销毁对象的非static成员
```c
class Foo {  

public:  
    // 其他操作  
    ~Foo(); // 析构函数  
};  
```
析构函数不接受参数，因此它不能被重载。对于一个给定的类，它又唯一的一个析构函数。  
### 析构函数作用
在一个构造函数中，数据成员的初始化在函数体执行之前执行的，初始化的顺序和它们在类中出现的顺序一致 ， 对于析构函数来说，数据成员的释放在函数体之后进行， 成员按照其初始化顺序的逆序进行销毁。（先函数体，在销毁成员）  
析构部分是隐式的，成员销毁在销毁时完全决定于成员的类型，如果是类类型，则执行类的析构函数，内置类型销毁什么也不需要做。** 隐式销毁一个内置指针类型的成员不会delete它所指向的对象。**

<font color=#0099ff>智能指针与普通指针不同，因为智能指针时类类型，因此智能指针有析构函数，智能指针成员在析构阶段会被自动销毁。
</font>

### 何时调用
无论何时一个对象被销毁，就会自动调用析构函数：
- 变量在离开其作用域时被销毁。
- 当一个对象被销毁时，其成员被销毁。
- 容器(无论是标准库容器还是数组)被销毁时，其元素被销毁。
- 对于动态分配的对象，当对指向它的指针delete时被销毁
- 对于临时对象，当创建它的完整表达式结束时被销毁。
```c
{  
    Sales_data* p = new Sales_data; // p是一个内置指针  
    auto p2 = make_shared<Sales_data>(); // p2是一个shared_ptr  

    Sales_data item(* p); // 拷贝构造函数将*p拷贝到item中  
    vector<Sales_data> vec;  
    vec.push_back(* p2); // 拷贝p2指向的对象，增加p2的计数  
    delete p; // 对p指向的对象执行析构函数  
} // 退出局部作用域，对item、vec、p2调用析构函数  
// 销毁p2会递减其引用计数，如果引用计数变为0， 对象被释放  
// 销毁vec会销毁它的元素  
```

### 合成的析构函数
类似拷贝构造函数和拷贝赋值运算符，如果类没有定义自己的析构函数，编译器为这个类生成一个合成的析构函数。 合成的析构函数的函数体是空的。
析构函数自身并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的，在整个对象的销毁时，析构函数体是作为成员销毁步骤之外的另一部分而进行的， 例如对内置指针的delete操作。
### 三/五法则
**需要析构函数的类也需要拷贝和赋值操作**  
当我们决定一个类是否需要它自己版本的拷贝控制成员时，一个基本的原则是这个类是否需要一个析构函数。如果一个类需要一个析构函数，几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符。
```c
class HasPtr {  

public:  
    HasPtr(const std::string& s = std::string()) : ps(new std::string(s)), i(0){}  

private:  
    std::string* ps;  
    int i;    
};  
```
对于HasPtr类来说，其构造函数为ps分配动态内存，合成的析构函数不会delete一个指针数据成员，因此，这个类需要定义自己的析构函数：

```c
~HasPtr() { delete ps; }
```
参考上面的原则，我们理应给HasPtr定义一个拷贝构造函数和拷贝赋值运算符，如果我们使用合成的拷贝构造函数和拷贝赋值运算符时， 将会发生严重的错误。  
我们在拷贝HasPtr对象时，这些函数简单的拷贝指针成员，意味着多个HasPtr对象可能指向相同的内存：
```c
HasPtr f (HasPtr hp) {  
    HasPtr ret = hp; // 拷贝给定的HasPtr  
    return ret; // ret和hp被释放  
}
```

当f返回时，hp和ret都被释放，两个对象的析构函数都被执行。于是会delete掉ret和hp的指针成员，但这个两个对象包含相同的指针值，因此会导致此指针被delete两次，发生了一个严重的错误； 另外使用函数 f 的返回值作为初始化值的对象时，指针被销毁，指向无效地址。因此，**我们需要定义自己的拷贝构造函数和拷贝赋值运算符。**  
```c
HasPtr& HasPtr(const HasPtr& has) {  

    ps  = new std::string(* (has.ps));  
    i   = has.i;  
    return * this;  
}  
```

需要拷贝操作的类也需要赋值操作，反之亦然.如果一个类需要一个拷贝构造函数，几乎可以肯定这个类也需要一个拷贝赋值运算符， 反之亦然。  
### =default：
我们可以将拷贝控制成员定义为=default来显示的要求编译器生成合成的版本。

```c
class Sales_data {  

public:  
    Sales_data() = default;  
    Sales_data(const Sales_data&) = default;  
    Sales_data& operator =(const Sales_data&);  
    ~Sales_data() = default;  
    // ...  
};  

Sales_data& Sales_data::operator = (const Sales_data& ) = default;  
```
在类内使用=default修饰成员的声明时，合成的函数隐式的被声明为内联的，如果不希望是内联的，我们应该在类外定义使用=default。
**只能对具有合成版本的成员函数使用=default。**

### =delete：
虽然大多数类应该定义拷贝构造函数和拷贝赋值运算符，但是对于某些类来说，这些操作没有合理的意义。例如，iostream类阻止了拷贝，一避免多个对象写入或读取相同的IO缓冲。  
在新的标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝。在函数的参数列表后面加上=delete 指出我们希望将它定义为删除的。我们虽然声明了它们，但不能以任何方式使用它们。
```c
struct NoCopy {  
    NoCopy() = default;  
    NoCopy(const NoCopy&) = delete; // 阻止拷贝  
    NoCopy& operator = (const NoCopy&) = delete;  // 阻止赋值  
    ~NoCopy() = default;  
    // 其他成员  
};  
```
=delete告诉编译器，我们不希望定义这些函数。  
=delete必须出现在函数第一次声明的时候。而且我们可以对任何函数指定=delete限定符。这是=delete和=default不同的两点。
### 析构函数不能是删除的成员
如果析构函数被定义为删除的，那么这个对象就无法销毁了，因此这个类也就无法定义它的变量或成员，但是可以动态分配这个类的对象，但是不能delete这个对象。    
前面说到，某些类的合成拷贝构造函数版本阻止拷贝对象，因为编译器合成的拷贝构造函数定义为删除的：


- 如果类的某个成员的析构函数是删除的或者不可访问的(例如，是private的)，则类的合成析构函数被定义为删除的
- 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的，如果类的某个成员析构函数是删除的或不可访问的，，则类合成的拷贝构造函数也被定义为删除的。
- 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或者是类有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的
- 如果类的某个成员的析构函数是删除的或是不可访问的，或是类有一个const成员，它没有类内初始化器且其类型未显示定义默认构造函数 ，或是类有一个引用成员，它没有类内初始化器，则该类的默认构造函数被定义为删除的  


本质上，如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数被定义为删除的。  
一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的。

## private 拷贝控制

在新标准发布之前，是通过将拷贝构造函数和拷贝赋值运算符置为私有的来阻止的。

# 拷贝控制和资源管理
## 定义行为像值的类
行为像值的类，例如标准库容器和std::string这样的类一样，类似这样的类我们可以简单的实现一个这样的类HasPtr。  
在实现之前，我们需要：  
- 定义一个拷贝构造函数，完成string的拷贝，而不是指向string的指针的拷贝；  
- 定义一个拷贝赋值运算符，释放当前的string，并从右侧拷贝新的string。  
- 定义一个析构函数来释放string    


```c
class HasPtr {  

public:  
    HasPtr(const std::string& s = std::string()) : ps(new std::string(s)), i(0) {}  

    HasPtr(const HasPtr& has) : ps(new std::string(*has.ps)), i(has.i) {}  

    HasPtr& operator = (const HasPtr& has);  

    ~HasPtr() { delete ps; }  
private:  
    std::string* ps;  
    int i;  
};  

HasPtr::operatpr = (const HasPtr& has) {  
    // 先定义一个局部变量保存右侧对象，如果右侧对象和左侧对象是同一个对象，那么先删除右侧对象就会发生错误  
    auto newPtr = new std::string(* has.ps);  
    // 此时再释放左侧对象资源  
    delete ps;  
    ps  = newPtr;  
    i   = has.i;  
}  
```
拷贝赋值运算符的实现中，为了安全起见，必须先将右侧对象拷贝到一个局部变量里，然后再删除左侧对象，然后将局部变量赋值给左侧对象。如果先删除左侧对象，此时右侧对象和左侧对象是同一个对象时，就会发生严重错误。  
**对于一个赋值运算符来说，一个好的方法是在左侧对象销毁之前拷贝右侧对象，因为左侧对象和右侧对象可能是同一个对象。**
## 定义行为像指针的类
行为像指针的类，例如智能指针shared_ptr。既然要让类的行为像一个指针，那么这个类就不能在执行析构函数时简单的释放相关联的string，如果只有一个对象指向这个string时，我们才可以在这个类的析构函数中释放资源，如果有多个类指向这个string，那么其中一个类释放了这个string，其他的类就不能再复用。  
因此就要用到**引用计数**的方法来解决这个问题。  

引用计数的工作方式如下：
- 除了初始化对象之外，每个构造函数(拷贝构造函数除外)都要创建一个引用计数，用来记录有多少对象共享正在创建的对象共享状态，当创建一个对象时，引用计数为1，因为此时只有一个对象共享。
- 拷贝构造函数不分配新得引用计数器，拷贝给定对象的数据成员，包括引用计数器，拷贝构造函数递增共享的计数器，表示给定对象更的状态又被一个新用户所共享
- 拷贝赋值运算符递减左侧运算对象的引用计数器，递增右侧对象的引用计数器，如果左侧对象的引用计数器为0，则销毁左侧对象。
- 析构函数判断引用计数是否为0，如果为0，则销毁左侧对象

引用计数的实现：我们假设有下面的情况：
```cpp
HasPtr h1;  
HasPtr h2(h1);  
HasPtr h3(h1);  
```
HasPtr是一个行为像指针的类，新创建的h1的引用计数为1，创建h2，用h1初始化h2，会递增h1的引用计数值，此时h2保存了h1中的引用计数，在创建h3的时候，递增了h1的引用计数值，而且我们必须做的是要更新h2中的引用计数值，此时无法更新h2中的引用计数值。因此，我们需要将引用计数保存在**动态内存**中，这样原对象和其他副本对象都会指向相同的计数器，这样就可以自动更新引用计数在每个共享对象中的状态。
```cpp
class HasPtr {  

public:  
    HasPtr(const std::string& s = std::string()) : ps(new std::string(s)), i(0), use(new size_t(1)) {}  

    HasPtr(const HasPtr& has) :  ps(has.ps), i(has.i), use(has.use) { ++ *use;}  

    HasPtr& operator = (const HasPtr& has);  

    ~HasPtr();  
private:  
    std::strin g* ps;  
    int i;  
    size_t* use; // 引用计数  
};  

HasPtr::HasPtr& operator = (const HasPtr& has) {  

    ++ *has.use;  //递增右侧运算对象的引用计数
    if (0 == *use) {  //递减被对象的引用计数，如果为0就删除释放
        delete ps;  
        delete use;  
    }  

    ps  =   has.ps;//然后更新数据  
    i   =   has.i;  
    use =   has.use;  
    return *this;  
}  

HasPtr::~HasPtr() {  

    if (--* use == 0) {  
        delete ps;  
        delete use;  
    }  
}  
```

注意的是，我们在拷贝一个HasPtr时，拷贝的是ps本身而不是ps指向的string。


# 交换操作
通常，管理资源的类除了定义拷贝控制成员之外，还会定义交换操作的函数swap。理论上来说，我们的swap函数应该是这样的：
```c
HasPtr temp = 1;  
v1 = v2;  
v2 = temp;  
```
这样的代码将v1中string拷贝了两次，但是这样做是没有必要的，我们希望swap交换指针，而不是分配string的副本：
```c
std::string* temp = v1.ps;  
v1.ps = v2.ps;  
v2.ps = temp;  
v1.i  = v2.i;  
```

我们将swap函数声明为HasPtr类的友元函数，这样swap就能访问HasPtr的ps和i成员：
```c
class HasPtr {  

    friend void swap(HasPtr&, HasPtr&);  
    // 其他定义  
};  

inline  
void swap(HasPtr& lhs, HasPtr& rhs) {  
    using std::swap;  
    swap(lhs.ps, rhs.ps);  
    swap(lhs.i, rhs.i);  
```
在swap函数中：  
使用了using std::swap，如果这个类有自己的swap函数，匹配程度会高于标准库swap，会优先使用类自己的swap，如果没有，则使用标准库的swap。  
swap里交换类的指针和int成员，并不会发生递归循环，HasPtr的数据成员是内置类型的，这时候会调用标准库版本的swap。

# 对象移动
## 右值引用
所谓的右值引用就是必须将引用绑定到右值的引用，我们通过**&&**来绑定到右值而不是&， **右值引用只能绑定到即将销毁的对象**。右值引用也是引用，因此右值引用也只不过是对象的别名而已。**右值引用可以绑定到要求转换的表达式、字面常量或者返回右值的表达式，但是右值不能绑定到一个左值上。**

```c
int i = 42;  
int &r = i; // 正确，r引用i  
int&& rr = i; // 错误，不能将右值引用绑定到左值  
int &r2 = i * 42; // 错误，i*42是一个右值  
const int& r3 = i * 42;  
int&& rr2 = i * 42;  
```
返回左值的函数、连同赋值、下标、解引用和前置递增或递减运算符都是返回左值的例子。  
返回非引用类型的函数、连同算数、关系、位以及后置递增或递减运算符，都是生成右值的例子。  

<font color=#ffd700 > 我们可以将一个const的左值引用或一个右值引用绑定到生成右值的例子上   
我们不能把右值直接绑定到一个变量上，即使这个变量时右值引用类型也不行。
</font>
## 标准库move函数：
我们可以通过标准库函数utility:move来获得绑定到左值上的右值引用。
```c
int&& rr3 = std::move(rr1);  
```
move旨在告诉编译器，我们希望把一个左值像右值一样使用它。使用move函数就意味着：除了对rr1赋值或销毁之外，我们不能再使用它。使用move之后，我们就不能对源对象的值做任何假设。

## 移动构造函数和移动赋值运算符
移动构造函数和移动赋值运算符移动对象资源，它们从对象中窃取资源，而不是像拷贝控制成员一样从对象拷贝资源。
我们为动态内存管理类添加移动构造函数：
```c
StrVec::StrVec(StrVec&& s) noexcepd : first(s.first), last_end(s.last_end), cap(s.cap){   
    s.first = s.last_end = s.cap = nullptr; // 将资源的源对象进入安全状态，对其运行析构函数是安全的。  
}  
```
移动构造函数类似拷贝构造函数，第一个形参必须是该类类型的一个引用，而其他额外的参数必须有默认实参。  
移动构造函数必须保证移动后源对象处于一个安全的状态：**析构它是无害的。 移动后，这些资源不再属于源对象。**  
移动构造函数在进行移动时，因为并没有分配任何资源，所以并不会抛出任何异常。当写一个不会抛出异常的程序时， 我们应该通知标准库。除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为我们的程序可能会抛出异常。  
为了通知标准库我们的移动构造函数不会抛出异常，我们的方法是在我们的移动构造函数中指明<font color=#ffd000>noexcept</font>。它放在函数的参数列表和初始化列表开始的冒号之间：
```c
class StrVec {  

public:  
    StrVec(StrVec&&) noexcept;  
    /*
    * /  
};  
```
类似const声明，我们需要在移动构造函数的声明和定义处都指定noexcept。


## 移动赋值运算符：
**移动后源对象必须可析构**，移动完成后原对象会被销毁，我们不能对移动后的源对象做任何假设。
```c
StrVec& StrVec::operator = (StrVec&& rhs) noexcept {  

    if (this != &rhs) {  

        free();  
        first = rhs.first;  
        last_end = rhs.last_end ;  
        cap  = rhs.cap;  
        rhs.first = rhs.last_end = rhs.cap = nullptr;  
    }  
    return * this;     
}  
```
## 合成的移动操作：
如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符和析构函数，那么编译器就不会为我们合成默认的移动操作。如果一个类没有对应的移动操作，则类使用拷贝操作来代替移动操作。

如果一个类没有定义任何拷贝操作，且类的每个非static成员都可以移动，编译器才会为它合成移动构造函数或移动赋值运算符。

移动操作不像拷贝操作，永远不会隐式的定义为删除的函数。如果我们显示的要求编译器生成=default的移动操作，且编译器不能移动所有成员，那么移动操作就会被定义为删除的。
- 与拷贝构造函数不同，移动构造函数被定义为删除的函数的条件是：有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或者是有类成员未定义自己的拷贝构造函数但是编译器不能为其合成移动构造函数。移动赋值运算符的情况类似。
- 如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或不可访问的(例如private），则类的移动构造函数或移动赋值运算符被定义为删除的。
- 类似拷贝构造函数，如果类的析构函数被定义为删除的或不可访问的， 则类的移动构造函数被定义为删除的。
- 类似拷贝赋值运算符，如果有类成员是const或是引用，则类的移动赋值运算符被定义为删除的。

## 移动迭代器
新标准库定义了一个移动迭代器 make_move_iterator， 它接受一个迭代器参数，将一个普通迭代器转换为一个移动迭代器。普通迭代器解引用得到的是左值，而移动迭代器解引用得到的是一个右值。

## 移动右值，拷贝左值。。。
当类有拷贝构造函数也有移动构造函数，那么判断右侧是右值还是左值，移动右值，拷贝左值。。。
## 但没有移动构造函数，右值也被拷贝
没移动构造函数，则使用拷贝构造函数

## 右值引用和成员函数
这种允许移动的成员函数通常使用拷贝/移动构造函数和赋值运算符相同的参数模式：一个指向const的左值引用，一个指向非const的右值引用。
```c
void push_back(const X&);  
void push_back(X&&);//移动，只能绑定到类型x的可修改的右值
class StrVec {  

public:  
    void push_back(const std::string&); // 拷贝元素  
    void push_back(std::string&&); // 移动元素  
    // 其他定义   
};  

void StrVec::push_back(const std::string& s) {  
    chk_n_alloc();  
    alloc.construct(last_end++, s);  
}  

void StrVec::push_back(std::string&& s) {  
    chk_n_alloc();  

```
## 右值和左值引用函数：
我们通常在对象上调用成员函数，不管这个对象是左值还是右值：
```c
string s1 = "a value", s2 = "another";  
auto n = (s1 + s2).find('a');  
```
```c
s1 + s2 = "wow";
```
在旧标准中存在这种使用方式，而新标准为了兼容旧标准，仍然保留了这种使用方式。
但我们可以在自己的类中阻止这种方式，我们希望强制左侧运算对象是一个左值。
我们指出this的左值/右值性质和const成员函数相同，在参数列表后面放置一个**引用限定符**。
```c
class Foo {  

public:  
    Foo& operator = (const Foo&) &; // 只能向可修改的左值赋值  
};  

Foo& Foo::operator = (const Foo& rhs)& {  
    // 赋值操作  
    return * this;  
}  
```
引用限定符可以&或&&， 分别指出this可以指向一个左值或右值，类似const限定符，引用限定符只能用于非static函数，而且必须同时出现在声明和定义中。
对于限定 &的函数，我们只能将它用于左值，限定&&的函数，只能用于右值。
可以同时用const和引用限定，不过引用限定符要跟在const之后。
```c
class Foo {  

public:  
    Foo someMem() & const;// 错误，const必须在引用限定符之前  
    Foo anotherMem() const &; // 正确  
};  
```
## 重载和引用函数：
